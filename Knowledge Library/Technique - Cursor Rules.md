# Practical Guide to Cursor Rules

_This document is a practical and comprehensive guide for creating and using Cursor Rules, focused on executable implementation and real-world examples. It was generated following the guidelines of the "Knowledge Researcher" framework._

## Executive Summary

**Cursor Rules** are a system of persistent instructions that guide the behavior of Cursor's AI agent, allowing you to customize its assistance to align with the specific needs of a project, team, or developer. They function as reusable context that is injected into the language model's prompt with each interaction, ensuring consistency and adherence to predefined patterns. Mastering Cursor Rules is crucial for transforming Cursor from a generic code assistant into a true development partner, capable of understanding and applying the nuances of your project, resulting in significantly increased productivity, reduced errors, and greater consistency in generated code.

The core concepts for effectively executing Cursor Rules include understanding the **different types of rules** (Project, User, Team, AGENTS.md), the **hierarchy of precedence** between them, **MDC syntax** with metadata for activation control, and the importance of **periodic reinforcement** to work around AI context window limitations. The power of Cursor Rules lies in their ability to encode domain knowledge, automate workflows, and standardize architecture and code style decisions. Current best practices emphasize creating short, focused, and actionable rules, using concrete code examples, and adopting a "critical partner" mindset where the AI is instructed to question and validate rather than just agree.

## Purpose and Expected Results

The main goal of mastering Cursor Rules is to transform AI interaction from simple prompt exchanges into deep, contextualized collaboration. By the end of this guide, you'll be able to instruct Cursor's AI agent with the precision of a senior team member who already knows your project's conventions and architecture.

**Real-World Use Cases:**
- **Accelerated Onboarding:** New team members can become productive faster, as the AI, guided by rules, already orients them on the project's best practices and standards.
- **Consistency at Scale:** In monorepos or projects with multiple contributors, rules ensure that code generated by the AI for different people maintains uniform style and architecture.
- **Guided Refactoring:** When performing large refactorings, rules can instruct the AI to follow the new pattern consistently across all modified files.
- **Task Automation:** Create templates for new components, services, or tests that can be generated by the AI with a single command, already following the correct structure.

**Tangible Results:**
- **High-Quality Code Generation:** AI-generated code will be more relevant, accurate, and aligned with your project's specificities.
- **Reduced Manual Editing:** You'll spend less time correcting and adjusting AI-generated code.
- **AI Autonomy:** The agent will be capable of performing more complex tasks with less supervision, such as following a sequence of commands to create and test a new feature.

**Success Indicators:**
- The AI starts suggesting the use of internal functions and patterns from your project without you needing to mention them explicitly.
- Generated code passes your project's linters and tests without requiring major modifications.
- You feel confident delegating more complex tasks to the AI, such as "implement this new endpoint following the existing service pattern."

**Time to Proficiency:**
- **Beginner (2-4 hours):** Capable of creating and applying simple rules (User Rules) and using ready-made templates from the community.
- **Intermediate (1-2 days):** Can create specific Project Rules with `globs` and `description`, organizing them into sections and using code examples.
- **Advanced (1 week):** Develops a cohesive rules system, combining different types, optimizing for tokens, and adopting the "critical partner" mindset to guide the AI in complex, multi-step tasks.

## Best Practices (Proven Execution Patterns)

Below is a table of proven best practices for writing and maintaining Cursor Rules, consolidated from official documentation, community repositories, and expert articles. Each practice is designed to be immediately executable.

| Practice | How to Execute | When to Use | Real Example | What Can Go Wrong |
| :--- | :--- | :--- | :--- | :--- |
| **Adopt "Critical Partner" Mindset** | Instruct the AI not to blindly agree. Use phrases like: `"Don't assume my conclusions are correct. Question my assumptions and offer counterpoints. Prioritize truth over agreement."` | In all `Always Apply` rules to ensure the AI acts as a code reviewer, not a passive assistant. | `## CRITICAL PARTNER MINDSET\nDo not affirm my statements or assume my conclusions are correct. Question assumptions, offer counterpoints, test reasoning. Prioritize truth over agreement.` | The AI may become overly cautious or ask for confirmation on simple tasks, requiring fine-tuning of instruction tone. |
| **Define Clear Execution Sequence** | Create a numbered section that dictates the order of AI actions. Ex: `1. SEARCH FIRST... 2. REUSE FIRST... 3. NO ASSUMPTIONS...` | For complex tasks involving code modification, ensuring the AI doesn't skip crucial steps like searching existing code. | `## EXECUTION SEQUENCE\n1. SEARCH FIRST - Use codebase_search/grep...\n2. REUSE FIRST - Check existing functions/patterns...\n3. NO ASSUMPTIONS - Only use: files read, user messages...` | The AI may follow the sequence too rigidly, becoming inefficient for tasks requiring creative deviation. Complex sequences can consume many tokens. |
| **Keep Rules Short and Focused** | Split monolithic rules into smaller, function-specific files. Keep each file under 500 lines, ideally less than 300. | When a rules file starts covering multiple contexts (e.g., frontend and backend) or becomes difficult to read and maintain. | Instead of one giant `general.mdc`, create `frontend.mdc`, `backend.mdc`, and `testing.mdc` within the `.cursor/rules/` folder. | Proliferation of many small rules files can make management complex if not well-organized in subdirectories. |
| **Use Concrete Code Examples** | Instead of describing a pattern, show it. Use formatted Markdown code blocks to illustrate the "right way" and, if needed, the "wrong way." | Whenever defining a coding pattern, component structure, or API format. Essential for framework rules. | `## Components\n- Use Server Components by default\n- Mark client components explicitly with 'use client'\n- Wrap client components in Suspense with fallback` | Very long or complex examples can consume a significant amount of context window tokens, leaving less space for the current prompt. |
| **Explicitly Mark Deprecated Patterns** | Use strong, direct language. Create a `## PROHIBITED ACTIONS` or `## DEPRECATED PATTERNS` section and list what the AI **MUST NOT** do. | When a library is updated, an architecture pattern changes, or to prevent the AI from using legacy solutions found in old parts of the code. | `## PROHIBITED ACTIONS\n- DO NOT WRITE DOCS UNLESS EXPLICITLY ASKED TO\n- NEVER run npm/yarn start commands - assume dev servers always running` | If not specific enough, the AI may avoid a valid pattern similar to the deprecated one. Must provide the correct alternative. |
| **Include Verification Steps** | Add a section at the end of the rule, like `## Verification Steps`, with a checklist the AI should perform to validate its own work. | To ensure generated code is functional and follows patterns. Especially useful for rules that generate tests or build configurations. | `## Verification Steps\n- Run 'npm run lint:ci' to check for linting errors.\n- Ensure all new components are exported from the main index file.` | The AI may hallucinate executing verification steps instead of actually performing them. Instructions must be clear about how verification should be done (e.g., using a terminal tool). |
| **Optimize Text for Tokens** | Use direct, imperative writing style ("do this", "don't do that"). Ask the AI itself to help shorten your rules: `"Rewrite these rules to be more concise, keeping the meaning."` | In `Always Apply` rules, where every token counts with each prompt. Essential for maintaining performance and reducing costs. | Transforming "It's important to maintain consistency with SOLID principles" to `"Keep code SOLID but simple"` saves tokens and is more direct. | Over-optimization can lead to loss of important nuances, making the rule ambiguous and less effective. |
| **Periodic Rule Reinforcement** | During a long conversation, if the AI seems to "forget" the rules, add a simple instruction to your prompt, like `"Remember the rules"` or `"Apply the development rules again."` | In long chat sessions (more than 10-15 messages), or when AI response quality starts visibly declining. | After a series of interactions, when requesting a new feature, add: `"Implement the checkout endpoint and remember to follow the execution rules and code patterns."` | Excessive use can be redundant and consume unnecessary tokens if the AI is still in the correct context. |
| **Organize Rules by Category and Scope** | Use the `.cursor/rules/` directory structure to nest rules. Place backend rules in `backend/.cursor/rules/` and frontend rules in `frontend/.cursor/rules/`. | In large projects or monorepos, where different parts of the code have distinct patterns and technologies. | `project/\n  .cursor/rules/      # Global project rules\n  backend/\n    .cursor/rules/  # Backend-specific rules (e.g., Go, Python)\n  frontend/\n    .cursor/rules/  # Frontend-specific rules (e.g., React, Next.js)` | A poorly planned directory structure can cause wrong rules to be applied or important rules to be ignored. |
| **Keep Rules Updated** | Create a team process to review and update rules files whenever a dependency is updated, an architecture pattern changes, or a new best practice is adopted. | Continuously. Rules are not "write and forget." They should evolve with the project. | During a Pull Request review that introduces a new library, the reviewer should also update the corresponding rules file to include best practices for the new library. | If rules aren't maintained, the AI will continue generating code based on outdated patterns, creating technical debt and rework. |

## Step-by-Step Implementation

This section provides a complete, executable process for implementing Cursor Rules, progressing from basic to advanced. Follow these steps to create a robust rules system that will transform your productivity.

### Level 1: Basic to Advanced - Creating Your First User Rule (Global)

Let's start with a simple rule that applies to all your projects to control the AI's communication style.

**Executable Process:**

1. **Open Cursor Settings:** Navigate to `Cursor Settings`.
2. **Find the Rules Section:** In the side menu, click on `Rules`.
3. **Add a New User Rule:** In the `User Rules (for Agent)` section, click `Add Rule`.
4. **Copy and Paste the Template:** In the text field that appears, paste the following template:

    ```
    # Communication Style
    
    - Respond concisely and directly.
    - Avoid unnecessary repetitions or filler language.
    - If unsure about an answer, state it explicitly.
    - Use bullet point lists for steps or multiple items.
    ```

5. **Save and Activate:** The rule is saved automatically and is already active for all your conversations with the Agent (Chat).

**Validation Point:**
- Start a new conversation with the Agent and ask a broad question like "explain what React is." Observe if the response is more structured and concise than usual. The response should avoid long paragraphs and go straight to the point.

**Troubleshooting Guide:**
- **Problem:** The AI doesn't seem to be following the rule.
- **Solution 1:** Check if the rule is enabled in the `Cursor Settings > Rules` panel. There should be a toggle activated next to it.
- **Solution 2:** Remember that `User Rules` apply mainly to the Agent Chat. They may not have as strong an impact on inline code edits (`Cmd/Ctrl + K`).

### Level 2: Intermediate - Creating Your First Project Rule (.mdc)

Now, let's create a project-specific rule ensuring the AI follows patterns for a specific technology stack (e.g., Next.js with TypeScript).

**Executable Process:**

1. **Open Command Palette:** In your Cursor project, open the command palette (`Cmd/Ctrl + Shift + P`).
2. **Execute New Rule Command:** Type `New Cursor Rule` and press Enter.
3. **Name Your Rule:** Give your rules file a name, for example, `nextjs-best-practices.mdc`. Cursor will automatically create the `.cursor/rules/` folder in your project root and place the file there.
4. **Copy and Paste the Template:** Cursor will open the new `.mdc` file. Replace the content with the template below. This template defines best practices for folder structure, components, and performance in a Next.js project.

    ```mdc
    ---
    description: "Best practices for Next.js with TypeScript and Tailwind CSS. Includes folder structure, Server/Client Components usage, and performance optimization."
    globs: ["**/*.tsx", "**/*.ts", "src/**/*.ts", "src/**/*.tsx"]
    ---
    
    # Next.js Best Practices
    
    ## Project Structure
    - Use the App Router directory structure (`app`).
    - Route-specific components should be inside the route folder in `app`.
    - Shared components should be placed in the `components` directory.
    - Utilities and helpers should go in the `lib` directory.
    
    ## Components
    - Prefer Server Components by default.
    - Mark client components explicitly with the `'use client'` directive at the top of the file.
    - Wrap client components in `Suspense` with a fallback for better loading experience.
    
    ## Performance
    - Optimize images using Next.js `<Image>` component and modern formats like WebP.
    - Minimize use of `useEffect` and `useState` in favor of server solutions whenever possible.
    ```

**Validation Point:**
- With the rule created, go to a `.tsx` file and ask the AI: `"create a new page component that fetches and displays a list of products"`. The AI should create the component as a Server Component by default (without `'use client'`) and, ideally, use `async/await` directly in the component function, following App Router best practices.

**Troubleshooting Guide:**
- **Problem:** The rule is not applied when editing a file.
- **Solution 1:** Check the `globs` in the `.mdc` file metadata. Make sure the pattern matches the path of the file you're editing.
- **Solution 2:** The `description` is crucial for intelligent activation (`Agent Requested`). Make sure it describes the rule content well so the AI knows when to use it.

### Level 3: Advanced - Building a Cohesive Rules System

At this level, you'll orchestrate multiple rules to create a robust system that guides the AI in complex tasks, adopting the "critical partner" mindset.

**Executable Process:**

1. **Create a "Mindset" Rule:** Create a new rules file called `mindset.mdc` in the `.cursor/rules/` folder. Configure it to always apply.

    ```mdc
    ---
    alwaysApply: true
    ---
    
    # STRICT RULES - CRITICAL PARTNER MINDSET
    
    - Don't assume my conclusions are correct. Question my assumptions and offer counterpoints.
    - Before implementing, search the codebase for existing functionality to reuse. Use search tools.
    - If you see failures, risks, or better approaches, state them directly.
    ```

2. **Create a Testing-Specific Rule:** Create a file `testing.mdc` with the following content:

    ```mdc
    ---
    description: "Rules for writing and running tests with Jest and React Testing Library."
    globs: ["**/*.test.tsx", "**/*.spec.ts"]
    ---
    
    # Testing Patterns
    
    - Use the AAA pattern (Arrange, Act, Assert) to structure tests.
    - Use `data-testid` to select elements instead of CSS selectors or text.
    - All component tests must include a basic accessibility check using `jest-axe`.
    ```

3. **Orchestrate the Rules:** Now you have an `Always Apply` rule (`mindset.mdc`) and two contextual rules (`nextjs-best-practices.mdc` and `testing.mdc`). Cursor will apply the mindset rule always, and the other two when the context (description or `globs`) is matched.

**Validation Point:**
- Go to a React component file and ask the AI: `"create tests for this component"`. The AI should:
    1. Apply the `mindset.mdc` rule and perhaps question if tests are really necessary or if they already exist.
    2. Apply the `testing.mdc` rule, using the AAA pattern and `data-testid`.
    3. Apply the `nextjs-best-practices.mdc` rule if the component uses something specific to Next.js.

**Troubleshooting Guide:**
- **Problem:** Rules seem to be in conflict.
- **Solution:** Remember the precedence hierarchy: **Team Rules > Project Rules > User Rules**. Within Project Rules, the specificity of `globs` and clarity of `description` help Cursor decide which rule is more relevant. If two rules conflict, the AI will try to merge the instructions, which can lead to unexpected results. Refine rules to be more orthogonal (covering different aspects) rather than overlapping.

## Common Mistakes and How to Avoid Them

Even with the best intentions, it's easy to make mistakes when writing Cursor Rules. This section details the most common errors, why they happen, and how to prevent and fix them, with practical examples for each.

| Common Mistake | Why It Happens | How to Prevent | How to Fix | Real Example |
| :--- | :--- | :--- | :--- | :--- |
| **Vague and Abstract Rules** | The developer tries to describe a high-level concept (e.g., "write clean code") without providing actionable instructions. The AI can't translate abstractions into concrete actions. | Be imperative and specific. Instead of "use good variable names", write "variable names must be in `camelCase`, descriptive, and at least 3 characters long". | Refactor the vague rule into a list of direct, executable instructions. Break the abstract concept into its practical components. | **Wrong:** `"Write performant code."`<br>**Right:** `"- Use \`React.memo\` on components with props that don't change frequently.\n- Use \`useCallback\` for functions passed as props to child components."` |
| **Forgetting "Periodic Reinforcement"** | The AI's context window is finite. In long conversations, initial rules leave the context and the AI "forgets" them, reverting to default behavior. | In chat sessions with more than 10-15 interactions, add a small phrase to your prompt, like `"...and remember to follow the project rules."` | If the AI generates a response that ignores the rules, edit your last prompt to include the reinforcement phrase and try again. Don't continue the conversation with the wrong response. | **Context:** After 20 messages, the AI generates a class component.<br>**Prompt Correction:** `"Create a login component, and remember we only use functional components with Hooks."` |
| **Rule Conflicts** | Multiple rules (e.g., a User Rule and a Project Rule) provide contradictory instructions on the same topic (e.g., formatting style). | Keep User Rules for personal preferences and communication style, and Project Rules for project technical standards. Understand the hierarchy (Team > Project > User). | Identify conflicting rules. Remove or refactor the instruction in the lower precedence rule (usually the User Rule) and let the more specific rule (Project Rule) be the source of truth. | **Conflict:** User Rule says "use double quotes". Project Rule says "use single quotes".<br>**Fix:** Remove the quotes instruction from the User Rule. |
| **Over-reliance on Intelligent Activation** | The developer writes an unclear or generic `description`, expecting the AI to magically know when to apply the rule `Apply Intelligently`. | Write the `description` as if explaining to a colleague when they should read that document. Include relevant keywords that will likely be in the prompt. | Edit the `description` to be more explicit. Add details about the technology, objective, and usage context of the rule. | **Wrong:** `description: "Component rules."`<br>**Right:** `description: "Patterns for creating new React components with TypeScript, including state, props, and styling with Tailwind CSS."` |
| **Not Keeping Rules Updated** | Rules are created and then abandoned. The project evolves, libraries are updated, but rules continue to instruct the AI with old patterns. | Create a team habit: when updating a dependency or changing an architecture pattern in a Pull Request, the same PR should include updating the corresponding `.cursor/rules/` file. | Do a periodic audit (e.g., quarterly) of all rules files. Run a simple test for each rule to ensure the generated code is still ideal. If not, update the rule. | **Scenario:** The team migrates from `Pages Router` to `App Router` in Next.js.<br>**Action:** The `nextjs.mdc` file should be immediately updated to remove `Pages Router` instructions and add `App Router` best practices. |
| **Ignoring Token Cost** | Creating extremely long and verbose `Always Apply` rules that consume a significant portion of the context window in every interaction, leaving less space for the actual prompt and increasing cost. | Use "military" writing style: direct, imperative, and concise. Use `##` for titles and `-` for lists. Avoid long paragraphs in `Always Apply` rules. Ask the AI to help optimize. | Analyze your `Always Apply` rules. Move very context-specific instructions to `Apply Intelligently` or `Apply to Specific Files` rules. Refactor text to be more information-dense. | **Wrong (in `alwaysApply`):** `"When you are working on our design system, it is very important that you consider using our design tokens that are defined..."`<br>**Right:** `"- Always use the design tokens defined in \`@/lib/tokens\` for colors, spacing, and typography."` |

## Practical Examples (Before/After)

This section demonstrates the practical impact of well-defined Cursor Rules through "before and after" examples. Each example is ready to be copied and adapted, showing how rules transform a generic AI interaction into precise, project-aligned collaboration.

### Example 1: Creating a New React Component

- **Context:** You need to create a new `Button` component in a project that uses TypeScript, Tailwind CSS, and has a strict naming and file structure pattern.
- **Applied Rule:** An `Apply Intelligently` rule with `description: "Patterns for creating new React components with TypeScript and Tailwind CSS"` and `globs: ["src/components/**/*.tsx"]`.

#### Wrong Way (Without Rules)

The developer asks: `> Create a button component called Button.`

The AI generates a `Button.jsx` file with generic code:

```jsx
// src/components/Button.jsx
import React from 'react';

const Button = ({ children, onClick }) => {
  return (
    <button onClick={onClick} style={{ padding: '10px 20px', borderRadius: '5px' }}>
      {children}
    </button>
  );
};

export default Button;
```

- **Why this fails:** The code completely ignores the project's stack. Uses inline `style` instead of Tailwind CSS, doesn't use TypeScript for props, and uses `export default` when the project pattern may be `named export`.

#### Right Way (With Rules)

The same rule from the previous example is active. The developer asks: `> Create a button component called Button.`

The AI generates the `index.tsx` file inside `src/components/Button/` with the following code:

```tsx
// src/components/Button/index.tsx
import React, { type ButtonHTMLAttributes } from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary';
}

export const Button = ({ children, className, variant = 'primary', ...props }: ButtonProps) => {
  const baseClasses = 'py-2 px-4 font-bold rounded-lg focus:outline-none';
  const variantClasses = {
    primary: 'bg-blue-500 text-white hover:bg-blue-700',
    secondary: 'bg-gray-500 text-white hover:bg-gray-700',
  };

  return (
    <button
      className={`${baseClasses} ${variantClasses[variant]} ${className}`}
      {...props}
    >
      {children}
    </button>
  );
};
```

- **Why this works:** The rule instructed the AI about the stack and patterns. The component uses TypeScript for props, uses Tailwind CSS classes for styling, and follows the folder structure pattern (`Component/index.tsx`) and `named export`.
- **Result:** Saves 5-10 minutes of manual refactoring. The generated code is immediately usable and consistent with the rest of the project.

### Example 2: Adding a New API Endpoint

- **Context:** Adding a `POST /api/users` endpoint in a Node.js backend with Express, which requires input validation with Zod and a controller/service architecture.
- **Applied Rule:** A rule with `description: "Patterns for creating new API endpoints with Express, Zod, and service architecture."`

#### Wrong Way (Without Rules)

The developer asks: `> Create an endpoint to register a new user.`

The AI adds the following to `server.js`:

```javascript
// server.js
app.post('/api/users', (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) {
    return res.status(400).send('Email and password are required');
  }
  // Logic to save user to database...
  res.status(201).send('User created');
});
```

- **Why this fails:** Business logic, validation, and data access are all mixed in the main API file, ignoring the project's architecture and validation library (Zod).

#### Right Way (With Rules)

The rule is active. The developer asks: `> Create an endpoint to register a new user.`

The AI generates/modifies three different files:

**1. `src/routes/userRoutes.ts`**
```typescript
import { Router } from 'express';
import { userController } from '../controllers/userController';

const router = Router();
router.post('/', userController.createUser);
export default router;
```

**2. `src/controllers/userController.ts`**
```typescript
import { Request, Response } from 'express';
import { userService } from '../services/userService';
import { createUserSchema } from '../schemas/userSchema';

export const userController = {
  async createUser(req: Request, res: Response) {
    const validatedData = createUserSchema.parse(req.body);
    const user = await userService.create(validatedData);
    res.status(201).json(user);
  },
};
```

**3. `src/schemas/userSchema.ts`**
```typescript
import { z } from 'zod';

export const createUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});
```

- **Why this works:** The rule guided the AI to follow the separation of concerns architecture (routes, controllers, services) and use the Zod library for validation, as defined in the project's patterns.
- **Result:** 70% reduction in implementation errors. The AI generates modular, testable, and maintainable code, saving significant development time.

### Example 3: Adopting the "Critical Partner" Mindset

- **Context:** A junior developer is trying to add a feature and asks the AI for help, but the proposed approach is inefficient.
- **Applied Rule:** An `Always Apply` rule with the instruction `## CRITICAL PARTNER MINDSET\n- Don't assume my conclusions are correct. If you see failures, risks, or better approaches, state them directly.`

#### Wrong Way (Without Rules)

The developer asks: `> To display the user's name on all pages, I'll fetch user data with a useEffect in each component. Help me write that useEffect.`

The AI, passively, generates the requested code:

```javascript
useEffect(() => {
  fetch('/api/user/me')
    .then(res => res.json())
    .then(data => setUser(data));
}, []);
```

- **Why this fails:** The AI simply obeys, implementing a cascading `fetch` pattern that is extremely inefficient and will lead to performance problems and poor user experience.

#### Right Way (With Rules)

The "critical partner" rule is active. The developer makes the same request.

The AI responds differently:

> **Approach Warning:** The approach you suggested of using `useEffect` in each component to fetch user data can lead to unnecessary multiple network calls and an inconsistent user experience.
> 
> **Better Alternative:** A more efficient approach would be to use React Context or a global state management library (like Zustand or Redux) to fetch user data once at the highest level of the application and make it available to all child components.
> 
> **Can I help you implement this approach with React Context? It would look something like this:**

```tsx
// src/contexts/AuthContext.tsx
// ...context provider code...
```

- **Why this works:** Instead of blindly following a bad instruction, the "critical partner" rule made the AI stop, analyze the request, identify a pattern failure, and propose an architecturally superior solution, explaining why.
- **Result:** Prevention of technical debt and future rework. The AI acts as a mentor, teaching best practices and ensuring the codebase remains healthy. The time saved here isn't measured in minutes, but in days or weeks that would be spent fixing this architecture error in the future.

## Understanding Rule Types and Hierarchy

### Rule Types

1. **Project Rules (`.cursor/rules/*.mdc`):**
   - Stored in your project's `.cursor/rules/` directory
   - Version-controlled with your codebase
   - Can use MDC metadata (`description`, `globs`, `alwaysApply`)
   - Scoped to specific files or always applied
   - Best for: Project-specific patterns, architecture decisions, technology stack conventions

2. **User Rules (Settings):**
   - Defined in Cursor Settings â†’ Rules
   - Apply globally across all projects
   - Plain text format
   - Best for: Personal preferences, communication style, global coding conventions

3. **Team Rules:**
   - Similar to Project Rules but shared across team members
   - Highest precedence in the hierarchy
   - Best for: Organization-wide standards

4. **AGENTS.md:**
   - Simple markdown file in project root
   - Alternative to Project Rules for straightforward cases
   - No metadata support
   - Best for: Simple, readable instructions without structured rules overhead

### Precedence Hierarchy

**Team Rules > Project Rules > User Rules**

When multiple rules apply, the AI merges instructions, but higher precedence rules take priority in conflicts. Within Project Rules, more specific `globs` and clearer `descriptions` help determine relevance.

## MDC Syntax Reference

MDC (Markdown with Metadata) is the format for Project Rules. Here's the syntax:

```mdc
---
description: "Brief description of what this rule does"
globs: ["**/*.tsx", "**/*.ts"]
alwaysApply: true
---

# Rule Title

Your rule content here...
```

**Metadata Fields:**
- **`description`:** Used for intelligent activation. Should include keywords relevant to when the rule should apply.
- **`globs`:** File path patterns (glob syntax) that determine which files this rule applies to.
- **`alwaysApply`:** Boolean. If `true`, the rule is always included in the context, regardless of file or prompt.

## Quality Checklist

Before considering your rules system complete, verify:

- [ ] **Rules are Focused:** Each rule addresses a specific aspect (not trying to cover everything)
- [ ] **Examples Included:** Rules have concrete code examples showing the "right way"
- [ ] **Deprecated Patterns Marked:** Old patterns are explicitly prohibited with alternatives provided
- [ ] **Verification Steps:** Rules that generate code include validation steps
- [ ] **Token Optimized:** `Always Apply` rules are concise and direct
- [ ] **Well Organized:** Rules are organized by category in appropriate directories
- [ ] **Up to Date:** Rules reflect current project dependencies and patterns
- [ ] **Critical Partner Enabled:** At least one rule encourages the AI to question and validate
- [ ] **Clear Descriptions:** `description` fields are explicit and keyword-rich
- [ ] **Proper Globs:** File patterns accurately match intended scope

## References

1. [Cursor Docs: Rules](https://cursor.com/docs/context/rules)
2. [awesome-cursorrules GitHub Repository](https://github.com/PatrickJS/awesome-cursorrules)
3. [Trigger.dev Blog: How to write great Cursor Rules](https://trigger.dev/blog/cursor-rules)
4. [Medium: Cursor Rules Best Practices for Developers](https://medium.com/elementor-engineers/cursor-rules-best-practices-for-developers-16a438a4935c)
5. [Cursor Directory](https://cursor.directory/)
6. [Cursor Rules Generator](https://cursorrules.org/en/)
7. [Cursor Changelog](https://cursor.com/changelog)
8. [Cursor Forum: A Deep Dive into Cursor Rules (> 0.45)](https://forum.cursor.com/t/a-deep-dive-into-cursor-rules-0-45/60721)

